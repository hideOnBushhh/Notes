# 前端模块化
#### 历程: 

 1. 函数封装: 一个文件编写几个相关函数
	- 污染了全局变量,无法规避命名冲突
	- 模块成员之间没什么联系?
 2. 对象: 把所有模块成员封装在一个对象中,通过对象名来调用
	- 外部可以随意修改内部成员
3. **匿名函数自执行: 隐藏内部成员,外部无法修改**
	- **这就是模块化的基础**

---	
#### 规范
目前通行的模块规范有两种:**CommonJS** 和 **AMD**

###### CommanJS
1. 根据CommonJS规范,一个单独的文件就是一个模块,每个模块都是单独的作用域,所以模块内部的变量,其他模块读取不到(除非定义为global对象的属性)
2. 模块输出: 只有一个出口module.exports对象,把需要模块输出的内容放入该对象
3. 加载使用模块: require方法,该方法读取一个文件并执行,返回文件内部的module.exports对象

但脚本标签天生异步，传统CommonJS模块在浏览器环境中无法正常加载。


###### AMD
异步模块定义,是一个浏览器端模块化开发的规范  

由于不是js原生支持,所以要用到库---requireJS

**requireJS主要解决两个问题**

1. 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器
2. js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长

**语法**

requireJS定义了一个函数 define，它是全局变量，用来定义模块
`define(id?, dependencies?, factory);`

1. id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）
2. dependencies：是一个当前模块依赖的模块名称数组
3. factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值

在页面上使用require函数加载模块

`require([dependencies], function(){});`

require()函数接受两个参数

1. 第一个参数是一个数组，表示所依赖的模块
2. 第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块


require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。


###### CMD
通用模块定义
依靠seaJS,解决的问题同上

**语法:**

define

`define(id?, deps?, factory)`

1. 因为CMD推崇一个文件一个模块，所以经常就用文件名作为模块id
2. CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写
	
	factory有三个参数
	
	`function(require, exports, module)`

	1. require

		require 是 factory 函数的第一个参数
	
		`require(id)`
		require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口
	
	2. exports
	
		exports 是一个对象，用来向外提供模块接口
	
	3. module
	
		module 是一个对象，上面存储了与当前模块相关联的一些属性和方法

加载模块

`seajs.use(['myModule.js'], function(my){});`



**AMD和CMD区别: **

- AMD: 依赖前置(在定义模块的时候就要声明其依赖的模块),
	- 在加载模块完成后就会执行该模块,所有模块加载+执行完后会进入require的回调函数,执行主逻辑,
	- 执行顺序与书写顺序不一定一致

- CMD: 就近依赖(只有在用到某个模块的时候再去require),
	- 在加载完某个依赖模块后并不执行,值是下载,所有模块加载完以后进入主逻辑,遇到require才执行对应的模块,
	- 执行顺序和书写顺序是一致的

	AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因